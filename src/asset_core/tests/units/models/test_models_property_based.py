"""
Property-based tests for data models using Hypothesis.

This module uses Hypothesis to generate a wide range of inputs for data models
to verify their integrity and validation logic under various conditions.

Preconditions:
    - `hypothesis` library must be installed.
    - Core data models (`Kline`, `Trade`) must be defined and importable.

Steps:
    1. Define strategies for generating `Kline` and `Trade` instances.
    2. Use `@given` to apply these strategies to test functions.
    3. Assert that model invariants and validation rules hold true.

Expected Result:
    - Tests should pass for all generated valid inputs.
    - Pydantic's `ValidationError` should be caught for invalid inputs.
"""

from datetime import datetime, timedelta
from decimal import Decimal

from asset_core.models.kline import Kline, KlineInterval
from asset_core.models.trade import Trade, TradeSide
from hypothesis import HealthCheck, given, settings
from hypothesis import strategies as st

# Strategy for generating valid decimals (prices, quantities)
valid_decimals = st.decimals(
    min_value="0.00000001", max_value="100000000", allow_nan=False, allow_infinity=False, places=8
)

# Strategy for generating timestamps
valid_datetimes = st.datetimes(min_value=datetime(2020, 1, 1), max_value=datetime(2030, 1, 1))


@st.composite
def kline_strategy(draw):
    """Hypothesis strategy to generate Kline instances."""
    # Generate time range - for MINUTE_1 interval, open_time must be aligned to minute boundaries
    base_time = draw(valid_datetimes)
    # Align to minute boundary (set seconds and microseconds to 0)
    open_time = base_time.replace(second=0, microsecond=0)
    # For MINUTE_1 interval, duration must be exactly 60 seconds
    close_time = open_time + timedelta(seconds=60)

    # Generate prices
    open_price = draw(valid_decimals)
    close_price = draw(valid_decimals)

    # Generate additional price points and ensure high/low constraints
    price1 = draw(valid_decimals)
    price2 = draw(valid_decimals)

    # Ensure high is the maximum and low is the minimum
    all_prices = [open_price, close_price, price1, price2]
    high_price = max(all_prices)
    low_price = min(all_prices)

    # Generate volumes
    volume = draw(valid_decimals)
    quote_volume = volume * close_price

    return Kline(
        symbol="BTCUSDT",
        interval=KlineInterval.MINUTE_1,
        open_time=open_time,
        close_time=close_time,
        open_price=open_price,
        high_price=high_price,
        low_price=low_price,
        close_price=close_price,
        volume=volume,
        quote_volume=quote_volume,
        trades_count=draw(st.integers(min_value=1, max_value=10000)),
    )


@st.composite
def trade_strategy(draw):
    """Hypothesis strategy to generate Trade instances."""
    # Generate price and quantity such that their product (volume) meets constraints
    # Volume must be >= 0.01 and <= 100000000
    price = draw(st.decimals(min_value=Decimal("0.01"), max_value=Decimal("100000"), places=8))

    # Calculate quantity range based on price to ensure volume constraints
    # Use a safer buffer to ensure volume is always above 0.01
    min_quantity = (Decimal("0.01") / price) * Decimal("1.01")  # Minimum to meet 0.01 volume with 1% buffer
    max_quantity = Decimal("100000000") / price  # Maximum to stay under volume limit

    # Ensure quantity is within reasonable bounds
    max_quantity = min(max_quantity, Decimal("1000000"))  # Cap at 1M for reasonableness

    quantity = draw(st.decimals(min_value=min_quantity, max_value=max_quantity, places=8))

    # Final safety check: ensure volume is at least 0.01
    volume = price * quantity
    if volume < Decimal("0.01"):
        quantity = Decimal("0.01") / price + Decimal("0.0001")  # Add small fixed buffer

    return Trade(
        symbol="BTCUSDT",
        trade_id=str(draw(st.uuids())),
        price=price,
        quantity=quantity,
        side=draw(st.sampled_from(TradeSide)),
        timestamp=draw(valid_datetimes),
    )


class TestModelPropertyBased:
    """Property-based tests for data models."""

    @given(kline_strategy())
    @settings(max_examples=10, suppress_health_check=[HealthCheck.too_slow])
    def test_kline_invariants(self, kline_instance: Kline):
        """
        Tests that Kline invariants (e.g., high >= low) hold true.

        Description:
            This test uses Hypothesis to generate a wide variety of Kline objects.
            It ensures that for any generated Kline, the `high` price is always
            greater than or equal to the `low` price, and that both are also
            consistent with the `open` and `close` prices.

        Preconditions:
            - A valid Kline instance generated by the kline_strategy.

        Steps:
            1. Generate a Kline instance using the strategy.
            2. Assert that `kline.high` is the maximum of the four prices.
            3. Assert that `kline.low` is the minimum of the four prices.

        Expected Result:
            - The assertions should always pass, confirming the model's
              internal validation logic for OHLC prices.
        """
        assert kline_instance.high_price == max(
            kline_instance.open_price, kline_instance.high_price, kline_instance.low_price, kline_instance.close_price
        )
        assert kline_instance.low_price == min(
            kline_instance.open_price, kline_instance.high_price, kline_instance.low_price, kline_instance.close_price
        )
        assert kline_instance.low_price > Decimal(0)

    @given(trade_strategy())
    @settings(max_examples=10)  # Reduce test examples for performance
    def test_trade_invariants(self, trade_instance: Trade):
        """
        Tests that Trade invariants (e.g., positive price) hold true.

        Description:
            This test uses Hypothesis to generate various Trade objects.
            It verifies that fundamental invariants, such as price and quantity
            always being positive, are maintained by the model's validation.

        Preconditions:
            - A valid Trade instance generated by the trade_strategy.

        Steps:
            1. Generate a Trade instance.
            2. Assert that `trade.price` is greater than zero.
            3. Assert that `trade.quantity` is greater than zero.

        Expected Result:
            - The assertions should always pass, ensuring data integrity.
        """
        assert trade_instance.price > Decimal(0)
        assert trade_instance.quantity > Decimal(0)
